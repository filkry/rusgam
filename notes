# The problem with D3D12 Lifetimes

We want to have a type Queue that cannot outlive another type Device.
So we don't want Device DROPPED during the time Queue exists.
However, we don't care about any other mutable operations on Device.
Unfortunately, mutable access to Device implies that the user could cause a DROP.
For this reason, the lifetime checker must verify that as long as Queue is depending on 'device, Device cannot be borrowed mutably.

Solutions:
1. Hand out HANDLEs rather than Queues. Store Queues inside the Device, and they can't be destroyed.
   No borrow dependency created, but kind of pushes the problem downstream to usage point.
2. Interior mutability. Basically do a runtime mutable borrow for any operation, and work around the fact we can't get a mutable ref to Device.
3. Some sort of separation between the Device and it's lifetime, like a token. Technically unsafe?
   CreateDevice would give back a device and a token, and any operations to create further objects would require the token and create a dependency to it.

More thoughts:
We never need a mutable reference to our structs, since we don't change them.
We don't know what is inside say an ID3D12CommandQueue, so we don't know when it's mutating.
In that circumstance, it seems like interior mutability is the only option, as we're just trying to recreate the data ownership needs without explicitly seeing them.
Interior mutability is the *only* way to actually make guarantees about the reference situation.
Most D3D12 objects allow multiple invocations anyway, I think, as they are thread-safe.
Again, we care about memory safety on the RUST side, not safety for the internal API STATE!
Interior mutability is there as a bonus to enforce the latter, but is not necessary for the former - regular lifetimes are the way to go for this.

Second pass thoughts after trying again:
I added lifetimes to all the D3D12 types, and safed3d12 compiled nicely, HOWEVER
This ends up poluting up the chain; anything with a D3D12 reference now has permanent "references" to other objects with D3D12 references
This means that the demand for interior mutability cannot be cordoned off to safed3d12; it pollutes high-level code as well
Where does that leave us?
Seems the only options are to be memory unsafe, accept interior mutability up the stack, or give up on static analysis.
Honestly, interior mutability is also a clusterfuck, it touches everything...
WHAT ELSE CAN WE DO??? THERE MUST BE AN ANSWER???

Maybe I should try and do away with all lifetime parameters in RustyD3D12 structs?
This is where I can break far from the API, so it seems like the place